function out = randomBalancePerms(in, distributeDim0, varargin)

% 
% out = RANDOMBALANCEPERMS(in, [dim], [flag])
%     [input] = for default you can input [], or omit if you don't use any inputs after it.
% 
% In the basic case, input a 2-D array of any data type. RANDOMBALANCEPERMS
% randomly permutes elements within each column. The random permutations are
% balanced across columns such that each row after contains an equal number of
% elements from each row before. Number of columns must be an integer multiple
% of number of rows.
% 
% e.g.
% 
% in =  [
%      1     2     3     4     5     6
%     11    12    13    14    15    16
%     21    22    23    24    25    26
%     ]
% ->
% out = [
%     11    22     3    14     5    26
%     21     2    13    24    15     6
%      1    12    23     4    25    16
%     ]
% 
% 
% Input can also be an array with any dimensions. Then RANDOMBALANCEPERMS
% permutes within each dimensions 2+, and the random permutations for each
% dimension are balanced across columns. Lengths in dimensions 2+ don't need to
% be the same. You can try this code as an example:
% 
% x(:,:,1) = [
%      1     2     3     4     5     6     7     8     9
%     11    12    13    14    15    16    17    18    19
%     21    22    23    24    25    26    27    28    29
%     ]
% x(:,:,2) = x(:,:,1)+0.1
% x(:,:,3) = x(:,:,1)+0.2
% randomBalancePerms(x)
% 
% By default RANDOMBALANCEPERMS shuffles MATLAB's random number generator before
% working. You can use flag -ns to not do this.
% 
% 
% INPUTS
% ----------
% 
% in
%     Array to permute.
% 
% [numSamples]
%     Dimension to balance permutations across.
% 
%     DEFAULT: 2 (columns)
% 
% [flag]
%     If you input the string "-ns" (" or ') then RANDOMBALANCEPERMS doesn't
%     shuffle MATLAB's random number generator.
% 
% 
% See also randomNum, randomNum_normal, randomRoll, randomChoose, randomOrder,
% perms, nchoosek, rep.


% Giles Holland 2022


if nargin < 2 || isempty(distributeDim0)
    distributeDim0 = 2;
end
flags = varargin;


    if nargin < 1
        error('Not enough inputs.')
    end
    if ~(isOneNum(distributeDim0) && isIntegerVal(distributeDim0) && distributeDim0 > 0)
        error('Dimension to balance across must be an integer >= 1.')
    end
    
flags = var2char(flags);


if ~any(strcmpi(flags, '-ns'))
    %Seed random number generator
    rng('shuffle')
end

numDims = ndims(in);


%Permute dimensions to distribute across to 1
transposeDims = [distributeDim0 remove(1:numDims, distributeDim0)];
in = permute(in, transposeDims);
% distributeDim -> 1;
% permuteDims -> 2:numDims;


siz = size(in);
distributeLength = siz(1);
    if ~isempty(in) && ~all(isIntegerVal(distributeLength./siz(2:end)))
        if numDims == 2
            error(['Size in the dimension to balance across (' num2str(distributeDim0) ') must be an integer multiple of size in the dimension to permute within.'])
        else
            error(['Size in the dimension to balance across (' num2str(distributeDim0) ') must be an integer multiple of size in each dimension to permute within.'])
        end
    end

    out = in;
for permuteDim = 2:numDims
    permuteLength = siz(permuteDim);
        
        aa = zeros(0, permuteLength);
    for n = 1:distributeLength/permuteLength
        %Use random Latin squares generated by toeplitz + randperm method.
        %Concatenate Latin squares to span all dim 1 if size in dim 1 > size in permutation dim.
        %Need to randperm independently for each Latin square else just end up with one random Latin square tiled.
        
        t = toeplitz([1 permuteLength:-1:2], [1 2:+1:permuteLength]);
        t = t(randperm(permuteLength), randperm(permuteLength));
        aa = [aa; t]; %#ok<*AGROW>
    end
        aa = reshape(aa, [distributeLength ones(1, permuteDim-1-1) permuteLength ones(1, numDims-permuteDim)]);
        aa = repmat(aa, [1 siz(2:permuteDim-1) 1 siz(permuteDim+1:end)]);
    
        bbb = cell(1, numDims);
    for dim = [1:permuteDim-1 permuteDim+1:numDims]
        bb = 1:siz(dim);
        bb = reshape(bb, [ones(1, dim-1) length(bb) ones(1, numDims-dim)]);
        bb = repmat(bb, [siz(1:dim-1) 1 siz(dim+1:end)]); 
        bbb{dim} = bb;
    end

    ii = sub2ind(siz, bbb{1:permuteDim-1}, aa, bbb{permuteDim+1:end});
    out = out(ii);
end
        

%Invert permutation for output
out = ipermute(out, transposeDims);